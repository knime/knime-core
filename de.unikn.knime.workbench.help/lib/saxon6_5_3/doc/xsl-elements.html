<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>XSLT Elements</title>
<link rel="stylesheet" type="text/css" href="saxon-style.css">
</head>

<body>

<div align=right><a href="index.html">Saxon home page</a></div>

<h1>XSLT Elements</h1>

<p>This page lists the standard XSL elements, all of which are supported in SAXON Stylesheets. For
extension elements provided with the SAXON product, see
 <a href="extensions.html">extensions.html</a>.</p>

<p>SAXON implements the XSLT version 1.0 specification from the World Wide Web Consortium:
 see <a href="conformance.html">Conformance</a>. This page is designed to
 give a summary of the features: for the full specification, consult the official standard.</p>


<table width="723">
  <tr>
    <td colspan=3 bgcolor="#0000FF"><font color="#FFFFFF"><big><b>Contents</b></big></font></td>
  </tr>

  <tr>

    <td VALIGN="top"  bgcolor="#00FFFF">
    <b>Standard XSL Elements</b><br>
    <a href="#xsl:apply-imports">xsl:apply-imports</a><br>
    <a href="#xsl:apply-templates">xsl:apply-templates</a><br>
    <a href="#xsl:attribute">xsl:attribute</a><br>
    <a href="#xsl:attribute-set">xsl:attribute-set</a><br>
    <a href="#xsl:call-template">xsl:call-template</a><br>
    <a href="#xsl:choose">xsl:choose</a><br>
    <a href="#xsl:comment">xsl:comment</a><br>
    <a href="#xsl:copy">xsl:copy</a><br>
    <a href="#xsl:copy-of">xsl:copy-of</a><br>
    <a href="#xsl:decimal-format">xsl:decimal-format</a><br>
    <a href="#xsl:document">xsl:document</a><br>
</td><td VALIGN="top"  bgcolor="#00FFFF">
    <a href="#xsl:element">xsl:element</a><br>
    <a href="#xsl:fallback">xsl:fallback</a><br> 
    <a href="#xsl:for-each">xsl:for-each</a><br> 
    <a href="#xsl:if">xsl:if</a><br>
    <a href="#xsl:include">xsl:include</a><br> 
    <a href="#xsl:import">xsl:import</a><br> 
    <a href="#xsl:key">xsl:key</a><br>
    <a href="#xsl:message">xsl:message</a><br>
    <a href="#xsl:namespace-alias">xsl:namespace-alias</a><br>
    <a href="#xsl:number">xsl:number</a><br>
    <a href="#xsl:otherwise">xsl:otherwise</a><br>
    <a href="#xsl:output">xsl:output</a><br>
</td><td VALIGN="top"  bgcolor="#00FFFF">
    <a href="#xsl:param">xsl:param</a><br>
    <a href="#xsl:processing-instruction">xsl:processing-instruction</a><br>
    <a href="#xsl:preserve-space">xsl:preserve-space</a><br>
    <a href="#xsl:script">xsl:script</a><br>
    <a href="#xsl:sort">xsl:sort</a><br>
    <a href="#xsl:strip-space">xsl:strip-space</a><br>
    <a href="#xsl:stylesheet">xsl:stylesheet</a><br>
    <a href="#xsl:template">xsl:template</a><br>
    <a href="#xsl:text">xsl:text</a><br>
    <a href="#xsl:value-of">xsl:value-of</a><br>
    <a href="#xsl:variable">xsl:variable</a><br>
    <a href="#xsl:when">xsl:when</a><br>
    <a href="#xsl:with-param">xsl:with-param</a><br>
    <br>
    <a href="#Literal Result Elements">Literal Result Elements</a><br>
    </td>


  </tr>
</table>

<h2>Standard XSLT Elements</h2>


<h3><a name="xsl:apply-imports">xsl:apply-imports</a></h3>


<p>The <b>xsl:apply-imports</b> element is used in conjunction with imported stylesheets. There
are no attributes. The element may contain zero or more xsl:with-param elements (as permitted
in XSLT 1.1 and XSLT 2.0).</p>

<p>At run-time, there must be a <i>current template</i>. A current template is established when
a template is activated as a result of a call on xsl:apply-templates. Calling xsl:call-template
does not change the current template. Calling xsl:for-each does not (as the XSLT standard says
 it should) cause the current template to become null.</p>

<p>The effect is to search for a template that matches the current node and that is defined in
a stylesheet that was imported (directly or indirectly, possibly via xsl:include) from the
stylesheet containing the current template, and whose mode matches the current mode.
 If there is such a template, it is activated using the current node. If not, the call on
 xsl:apply-imports has no effect.</p>




<hr>




<h3><a name="xsl:apply-templates">xsl:apply-templates</a></h3>

<p>The xsl:apply-templates element causes navigation from the current element, usually
but not necessarily to process its children. Each selected node is processed using
the best-match <b>xsl:template</b> defined for that node. </p>

<p>The <b>xsl:apply-templates</b> element takes an optional attribute, <b>mode</b>, which identifies the
processing mode. If this attribute is present, only templates with a matching <b>mode</b> parameter will
be considered when searching for the rule to apply to the selected elements.</p>

<p>It also takes an optional attribute, <b>select</b>.</p>

<p>If the <b>select</b> attribute is <i>omitted</i>, apply-templates causes all the immediate
children of the current node to be processed: that is, child elements and
character content, in the order in which it appears. Character content must be processed by
a template whose match pattern will be something like "*/text()". Child elements similarly
 are processed using the appropriate template,
 selected according to the rules given below under <a href="#xsl:template">xsl:template</a>.</p>

<p>If the <b>select</b> attribute is <i>included</i>, it must be a <i>node set expression</i> which
identifies the nodes to be processed. All nodes selected by the expression are processed.</p>

<p>The <b>xsl:apply-templates</b> element is usually empty, in which case the selected nodes are
processed in the order they appear in the source document. However it may include xsl:sort and/or
xsl:param elements: <ul>

<li>For sorted processing, one or more
child <a href="#xsl:sort">xsl:sort</a> elements may be included. These define the sort order to be applied to the
selection. The sort keys are listed in major-to-minor order.</li>

<li>To supply parameters to the called template, one or more <a href="#xsl:with-param">xsl:with-param</a> elements
may be included. The values of these parameters are available to the called template.</li>
</ul></p>

<p>The selected nodes are processed in a particular <i>context</i>. This context includes:<ul>

<li>A current node: the node being processed</li>
<li>A current node list: the list of nodes being processed, in the order they are processed (this affects the
 value of the position() and last() functions)</li>
<li>A set of variables, which initially is those variable defined as parameters</li>
</ul></p>


<p>Some examples of the most useful forms of select expression are listed below:</p>
</font>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="590">
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2"><b>Expression</b></font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2"><b>Meaning</b></font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all immediate child elements with tag XXX</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">*</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all immediate child elements
     (but not character data within the element)</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">../TITLE</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process the TITLE children of the parent element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[@AAA]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all XXX child elements having
    an attribute named AAA</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">@*</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all attributes of the current element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">*/ZZZ</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all grandchild ZZZ elements </font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[ZZZ]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all child XXX elements that have a child ZZZ</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">XXX[@WIDTH and not(@WIDTH="20")]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process all child XXX elements that have a WIDTH attribute whose
     value is not "20"</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">AUTHOR[1]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process the first child AUTHOR element</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">APPENDIX[@NUMBER][last()]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process the last child APPENDIX element having a NUMBER
     attribute</font></td>
  </tr>
  <tr>
    <td WIDTH="24%" VALIGN="TOP"><font SIZE="2">APPENDIX[last()][@NUMBER]</font></td>
    <td WIDTH="76%" VALIGN="TOP"><font SIZE="2">Process the last child APPENDIX element provided
    it has a NUMBER attribute</font></td>
  </tr>
  
</table>


<p>The full syntax of select expressions is given in <a href="expressions.html">XPath Expression Syntax</a></h3>


<hr>

<h3><a name="xsl:attribute">xsl:attribute</a></h3>

<p>The <b>xsl:attribute</b> element is used to add an attribute value to an
<b>xsl:element</b> element or general formatting element, or to an element created using <b>xsl:copy</b>.
The attribute must be output immediately after the element, with no intervening character data.
 The name of the attribute is indicated by the
<b>name</b> attribute and the value by the content of the xsl:attribute element.</p>

<p>The attribute name is interpreted as an <i>attribute value template</i>, so it may contain string expressions
within curly braces. The full syntax of string expressions is given in <a href="expressions.html">XPath Expression Syntax</a>
</p>

<p>For example, the following code creates a &lt;FONT&gt; element with several attributes:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:element name="FONT"&gt;
    &lt;xsl:attribute name="SIZE"&gt;4&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="FACE"&gt;Courier New&lt;/xsl:attribute&gt;
Some output text
&lt;/xsl:element&gt;
    </pre></font></td>
  </tr>
</table>
</p>

<p>There are two main uses for the <b>xsl:attribute</b> element: </p>
<ul>
<li>It is the only way to set attributes on an element generated dynamically using xsl:element</li>
<li>It allows attributes of a literal result element to be calculated using xsl:value-of.</li>
</ul>

<p>The xsl:attribute must be output immediately after the relevant element is generated: there must
be no intervening character data (other than white space which is ignored). SAXON outputs the closing
"&gt;" of the element start tag as soon as something other than an attribute is written to the output
stream, and rejects an attempt to output an attribute if there is no currently-open start tag. Any special
characters within the attribute value will automatically be escaped (for example, "&lt;" will be output as
"&amp;lt;")</p>

<p>If two attributes are output with the same name, the second one takes precedence.</p>

<p>Saxon permits the additional attribute <b>saxon:disable-output-escaping</b>. If this is set to
the value "yes", then the attribute value will be output as-is, without escaping of special
characters. This affects both the normal XML escaping (e.g. of ampersand) and the special URL
escaping that occurs with non-ASCII characters in HTML URL attributes (e.g. href) which normally causes
a space to be output as %20.</p>


<hr>
<h3><a name="xsl:attribute-set">xsl:attribute-set</a></h3>


<p>The <b>xsl:attribute-set</b> element is used to declare a named collection of attributes, which will often
be used together to define an output style. It is declared at the top level (subordinate to xsl:stylesheet).</p>

<p>An attribute-set contains a collection of xsl:attribute elements.</p>

<p>The attributes in an attribute-set can be used in several ways:<ul>
<li>They can be added to a literal result element by specifying xsl:use-attribute-sets in the list of attributes
for the element. The value is a space-separated list of attribute-set names. Attributes specified explicitly on
the literal result element, or added using xsl:attribute, override any that are specified in the attribute-set
definition.</li>
<li>They can be added to an element created using xsl:element, by specifying use-attribute-sets in the list of attributes
for the xsl:element element. The value is a space-separated list of attribute-set names. Attributes specified explicitly on
the literal result element, or added using xsl:attribute, override any that are specified in the attribute-set
definition.</li>
<li>One attribute set can be based on another by specifying use-attribute-sets in the list of attributes
for the xsl:attribute-set element. Again, attributes defined explicitly in the attribute set override any that
are included implicitly from another attribute set.</li>
</ul></p>

<p>Attribute sets named in the xsl:use-attribute-sets or use-attribute-sets attribute 
are applied in the order given: if the same attribute is generated more than once, the later value always takes
precedence.</p>


<hr>


<h3><a name="xsl:call-template">xsl:call-template</a></h3>


<p>The <b>xsl:call-template</b> element is used to invoke a named template.</p>

<p>The <b>name</b> attribute is mandatory and must match the name defined on an xsl:template element.<p>

<p>Saxon supports an additional attribute <b>saxon:allow-avt</b>. If this is present and is set to the
value "yes", then the <b>name</b> attribute may be written as an attribute value template, allowing
the called template to be decided at run-time. The string result of evaluating the attribute value
template must be a valid QName that identifies a named template somewhere in the stylesheet.</p>

<p>Parameters to the called template may be defined using <a href="#xsl:with-param">xsl:with-param</a>
 elements nested within the xsl:call-template element.</p>

<p>The context of the called template (for example the current node and current node list) is the same as
that for the calling template; however the variables defined in the calling template are not accessible in
the called template.</p>

</font>

<hr>


<h3><a name="xsl:choose">xsl:choose</a></h3>


<p>The <b>xsl:choose</b> element is used to choose one of a number of alternative outputs. The element
typically contains a number of <a href="#xsl:when">xsl:when</a> elements, each with a separate test condition. The first
xsl:when element whose condition matches the current element in the source document is expanded, the others
are ignored. If none of the conditions is satisfied, the <a href="#xsl:otherwise">xsl:otherwise</a> child element, if any, is
expanded.</p>

<p>The test condition in the xsl:when element is a boolean expression.
The full syntax of expressions is given in <a href="expressions.html">XPath Expression Syntax</a></h3>


<p>Example:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:choose&gt;
    &lt;xsl:when test="@cat='F'"&gt;Fiction&lt;/xsl:when&gt;
    &lt;xsl:when test="@cat='C'"&gt;Crime&lt;/xsl:when&gt;
    &lt;xsl:when test="@cat='R'"&gt;Reference&lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;General&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
    </pre></font></td>
  </tr>
</table>
</p>





<hr>


<h3><a name="xsl:comment">xsl:comment</a></h3>


<p>The <b>xsl:comment</b> element can appear anywhere within an xsl:template. It indicates
text that is to be output to the current output stream in the form of an XML or HTML
comment.</p>

<p>For example, the text below inserts some JavaScript into a generated HTML document:</p>
</font><div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;script language=&quot;JavaScript&quot;&gt;
    &lt;xsl:comment&gt;
        function bk(n) {
            parent.frames['content'].location=&quot;chap&quot; + n + &quot;.1.html&quot;;
        }
    //&lt;/xsl:comment&gt;
&lt;/script&gt;
</pre></font></td>
  </tr>
</table>
</div><font SIZE="2">

<p>Note that special characters occurring within the comment text will <i>not</i>
be escaped.</p>

<p>The xsl:comment element will normally contain text only but it may contain other
elements such as <a href="#xsl:if"><b>xsl:if</b></a> or <a href="#xsl:value-of"><b>xsl:value-of</b></a>.
However, it should not contain literal result elements.
</p>

<p><i>Tip: the xsl:comment element can be very useful for debugging your stylesheet. Use comments in the generated
output as a way of tracking which rules in the stylesheet were invoked to produce the output.</i></p>


<hr>



<h3><a name="xsl:copy">xsl:copy</a></h3>


<p>The <b>xsl:copy</b> element causes the current XML node in the source document to be copied to the
output. The actual effect depends on whether the node is an element, an attribute, or a text node.<p>

<p>For an element, the start and end element tags are copied; the attributes, character content and child elements
are copied only if <b>xsl:apply-templates</b> is used within xsl:copy.</p>

<p>Attributes of the generated element can be defined by reference to a named attribute set.
The optional use-attribute-sets attribute contains a white-space-separated list of attribute set names. They
are applied in the order given: if the same attribute is generated more than once, the later value always takes
precedence.</p>

<p>The following example is a template that copies the input element to the output, together with all its
child elements, character content, and attributes:</p>

<p><table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font face="Courier New" size="3">
<pre>
&lt;xsl:template match="*|text()|@*"&gt;
    &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select="@*"/&gt;
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</pre>
    </font></td>
  </tr>
</table></p>





<hr>

<h3><a name="xsl:copy-of">xsl:copy-of</a></h3>


<p>The xsl:copy-of element copies of the value of the
expression in the mandatory <b>select</b> attribute to the result tree</p>

<p>If this expression is a string, a number, or a boolean, the effect is the same as using
xsl:value-of. It is usually used where the value is a nodeset or a result tree fragment.</p>


<hr>



<h3><a name="xsl:decimal-format">xsl:decimal-format</a></h3>


<p>The <b>xsl:decimal-format</b> element is used at the top level of a stylesheet to indicate a set of localisation
parameters. If the xsl:decimal-format element has a name attribute, it identifies a named format; if not, it identifies the
default format.</p>

<p>In practice decimal formats are used only for formatting numbers using the format-number() function in XSL expressions.
For details of the attributes available, see the XSLT specification.</p>

<hr>


<h3><a name="xsl:document">xsl:document</a></h3>

<p>The <code>xsl:document</code> element was introduced in XSLT 1.1, and is implemented in Saxon as 
a replacement for the previous extension element
saxon:output. It is a forerunner of the XSLT 2.0 instruction <code>xsl:result-document</code>.
It is used to direct output to a secondary output destination. It is available
only when the stylesheet specifies <emph>forwards-compatibility mode</emph>, that is,
when the <code>version</code> attribute on <code>xsl:stylesheet</code> or the <code>xsl:version</code>
element on a containing literal result element has a value other than <code>1.0</code> (The value
<code>1.1</code> is recommended but not strictly necessary).</p>

<p>Most of the attributes are the same as for <a href="#xsl:output">xsl:output</a>,
 including the additional extension attributes supported by Saxon. The one addition is
 the mandatory <code>href</code> attribute, which defines the destination of the output after
 serialization. In this version of Saxon, the <code>href</code> attribute is interpreted as
 a filename (not a URI) relative to the current working directory.</p>

<p>Here is an example that uses xsl:document:</p>
<div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;preface&quot;&gt;
    &lt;xsl:document href="{$dir}\preface.html"&gt;
        &lt;html&gt;&lt;body bgcolor=&quot;#00eeee&quot;&gt;&lt;center&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/center&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt;
    &lt;/xsl:document&gt;
    &lt;a href="{$dir}\preface.html"&gt;Preface&lt;/a&gt;
&lt;/xsl:template&gt;</pre>
</font></td>
  </tr>
</table>
</div>


<p>Here the body of the preface is directed to a file called preface.html (prefixed
by a parameter that supplies the directory name). Output then reverts to the previous destination,
where an HTML hyperlink to the newly created file is inserted.</p>


<hr>


<h3><a name="xsl:element">xsl:element</a></h3>

<p>The <b>xsl:element</b> is used to create an output element whose name might be calculated at run-time.</p>

<p>The element has a mandatory attribute, <b>name</b>, which is the name of the generated element.
 The name attribute is an <i>attribute value template</i>, so it may contain string expressions inside
 curly braces.</p>

<p>The attributes of the generated element are defined by subsequent <b>xsl:attribute</b> elements. The
content of the generated element is whatever is generated between the <b>&lt;xsl:element&gt;</b> and
<b>&lt;/xsl:element&gt;</b> tags.</p>

<p>Additionally, attributes of the generated element can be defined by reference to a named attribute set.
The optional use-attribute-sets attribute contains a white-space-separated list of attribute set names. They
are applied in the order given: if the same attribute is generated more than once, the later value always takes
precedence.</p>

<p>For example, the following code creates a &lt;FONT&gt; element with several attributes:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:element name="FONT"&gt;
    &lt;xsl:attribute name="SIZE"&gt;4&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="FACE"&gt;Courier New&lt;/xsl:attribute&gt;
Some output text
&lt;/xsl:element&gt;</pre></font></td>
  </tr>
</table>
</p>


<hr>


<h3><a name="xsl:fallback">xsl:fallback</a></h3>


<p>The <b>xsl:fallback</b> element is used to define recovery action to be taken when an instruction
element is used in the stylesheet and no implentation of that element is available. An element is an
instruction element if its namespace URI is the standard URI for XSL elements
or if its namespace is identified in the
xsl:extension-element-prefixes attribute of a containing literal result element, or in the
extension-element-prefixes attribute of the xsl:stylesheet element.</p>

<p>If the xsl:fallback element appears in
any other context, it is ignored, together with all its child and descendant elements.</p>

<p>There are no attributes.<p>

<p>If the parent element can be instantiated and processed, the xsl:fallback element
and its descendants are ignored. If the parent element is not recognised of if any failure occurs
 instantiating it,
 all its xsl:fallback children are processed in turn. If there are no xsl:fallback children, an
 error is reported.</p>

<hr>



<h3><a name="xsl:for-each">xsl:for-each</a></h3>


<p>The <b>xsl:for-each</b> element causes iteration over the nodes selected by a node-set expression.
It can be used as an alternative to <b>xsl:apply-templates</b> where the child nodes of the
current node are known in advance. There is a mandatory attribute, <b>select</b>, which defines
the nodes over which the statement will iterate. The XSL statements subordinate to the xsl:for-each element
are applied to each source node seleced by the node-set expression in turn.<p>

<p>The full syntax of node-set expressions is given in <a href="expressions.html">XPath Expression Syntax</a></h3>

<p>The xsl:for-each element may have one or more <b>xsl:sort</b> child elements to define the order of
 sorting. The sort keys are specified in major-to-minor order.</p>

<p>The expression used for sorting can be any string expressions. The following are
particularly useful:</p>

<ul>
<li>element-name, e.g. TITLE: sorts on the value of a child element</li>
<li>attribute-name, e.g. @CODE: sorts on the value of an attribute</li>
<li>".": sorts  on the character content of the element</li>
<li>"qname(.)": sorts on the name of the element</li>
</ul>

<p>Example 1:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match="BOOKLIST"&gt;
    &lt;TABLE&gt;
    &lt;xsl:for-each select="BOOK"&gt;
        &lt;TR&gt;
        &lt;TD&gt;&lt;xsl:value-of select="TITLE"/&gt;&lt;/TD&gt;
        &lt;TD&gt;&lt;xsl:value-of select="AUTHOR"/&gt;&lt;/TD&gt;
        &lt;TD&gt;&lt;xsl:value-of select="ISBN"/&gt;&lt;/TD&gt;
        &lt;/TR&gt;        
    &lt;/xsl:for-each&gt;
    &lt;/TABLE&gt;
&lt;/xsl:template&gt;</pre>
    </font></td>
  </tr>
</table>
</p>

<p>Example 2: sorting with xsl:for-each. This example also shows a template for a BOOKLIST
element which processes all the child BOOK elements in order of their child AUTHOR elements.</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;BOOKLIST&quot;&gt;
    &lt;h2&gt;
        &lt;xsl:for-each select="BOOK"&gt;
            &lt;xsl:sort select="AUTHOR"/&gt;
            &lt;p&gt;AUTHOR: &ltxsl:value-of select="AUTHOR"/&gt;&lt;/p&gt;
            &lt;p&gt;TITLE: &ltxsl:value-of select="TITLE"/&gt;&lt;/p&gt;
            &lt;hr/&gt;
        &lt;/xsl:for-each&gt;            
    &lt;/h2&gt;
&lt;/xsl:template&gt;</pre>
    </font></td>
  </tr>
</table>
</div>



<hr>





<h3><a name="xsl:if">xsl:if</a></h3>


<p>The <b>xsl:if</b> element is used for conditional processing. It takes a mandatory <b>test</b>
attribute, whose value is a boolean expression. The contents of the xsl:if element are expanded only
of the expression is true.</p>

<p>The full syntax of boolean expressions is given in <a href="expressions.html">XPath Expression Syntax</a></h3>
</p>

<p>Example:</p>
</font><div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:if test=&quot;@preface&quot;&gt;
        &lt;a href=&quot;preface.html&quot;&gt;Preface&lt;/a&gt;
&lt;/xsl:if&gt;</pre>
    </font></td>
  </tr>
</table>
</div><font SIZE="2">

<p>This includes a hyperlink in the output only if the current element has a <b>preface</b>
attribute.</p>


<hr>




<h3><a name="xsl:include">xsl:include</a></h3>


<p>The <b>xsl:include</b> element is always used at the top level of the stylesheet. It has a
mandatory <b>href</b> attribute, which is a URL (absolute or relative) of another stylesheet
to be textually included within this one. The top-level elements of the included stylesheet
effectively replace the xsl:include element.</p>

<p>xsl:include may also be used at the top level of the included stylesheet, and so
on recursively.</p>


<hr>


<h3><a name="xsl:import">xsl:import</a></h3>


<p>The <b>xsl:import</b> element is always used at the top level of the stylesheet, and it must
 appear before all other elements at the top level. It has a
mandatory <b>href</b> attribute, which is a URL (absolute or relative) of another stylesheet
to be textually included within this one. The top-level elements of the included stylesheet
effectively replace the xsl:import element.</p>

<p>xsl:import may also be used at the top level of the included stylesheet, and so
on recursively.</p>

<p>The elements in the imported stylesheet have lower precedence than the elements in the
importing stylesheet. The main effect of this is on selection of a template when xsl:apply-templates
is used: if there is a matching template with precedence X, all templates with precedence less than
X are ignored, regardless of their priority.</p>


<hr>


<h3><a name="xsl:key">xsl:key</a></h3>


<p>The <b>xsl:key</b> element is used at the top level of the stylesheet to declare an attribute, or other value,
that may be used as a key to identify nodes using the key() function within an expression. Each xsl:key
definition declares a named key, which must match the name of the key used in the key() function.</p>

<p>The set of nodes to which the key applies is defined by a pattern in the match attribute: for example,
if match="ACT|SCENE" then every ACT element and every SCENE element is indexed by this key.</p>

<p>The value of the key, for each of these matched elements, is determined by the <b>use</b> attribute.
This is an expression, which is evaluated for each matched element. If the expression returns a node-set,
the string value of each node in this node-set acts as a key value. For example, if use="AUTHOR", then each
AUTHOR child of the matched element supplies one key value. If the expression returns any other value, the value
is converted to a string and that string acts as the key.</p>

<p>Note that<ol>
<li>Keys are not unique: the same value may identify many different nodes</li>
<li>Keys are multi-valued: each matched node may have several (zero or more) values of the key, any one
of which may be used to locate that node</li>
<li>Keys can only be used to identify nodes within a single XML document: the key() function will return nodes
 that are in the same document as the current node.
</ol></p>

<p>All three attributes, name, match, and use, are mandatory.</p>


<hr>





<h3><a name="xsl:message">xsl:message</a></h3>


<p>The <b>xsl:message</b> element causes a message to be displayed. The message
is the contents of the xsl:message element.</p>

<p>There is an optional attribute <b>terminate</b> with permitted values yes and no; the default is no. If the
value is set to yes, processing of the stylesheet is terminated after issuing the message.</p>

<p>By default the message is displayed on the standard error output stream. You can supply your
own message Emitter if you want it handled differently. This must be a class that implements
the com.icl.saxon.output.Emitter interface. The content of the message is in general an
XML fragment. You can supply the emitter using the -m option on the command line, or the
setMessageEmitter() method of the Controller class.</p>

<p>No newline is added to the message; if you want one, include it in the text using &amp;#xa;,
as in the example below.</p>

<p>Example: This example displays an error message.</p>
 
</font><div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
    &lt;xsl:template match="BOOK"&gt;
        &lt;xsl:if test="not(@AUTHOR)"&gt;
            &lt;xsl:message&gtError: BOOK found with no AUTHOR!&amp;#xa;&lt;/xsl:message&gt
        &lt;/xsl:if&gt;
    ...
    &lt;/xsl:template&gt;
</pre>
    </font></td>
  </tr>
</table>
</div>


<hr>




<h3><a name="xsl:namespace-alias">xsl:namespace-alias</a></h3>


<p>The <b>xsl:namespace-alias</b> element is a top-level element that is used to control the mapping
between a namespace URI used in the stylesheet and the corresponding namespace URI used in the result
 document.</p>

<p>Normally when a literal result element is encountered in a template, the namespace used for the element
name and attribute names in the result document is the same as the namespace used in the stylesheet. If
a different namespace is wanted (e.g. because the result document is a stylesheet using the XSLT namespace),
then xsl:namespace-alias can be used to define the mapping.</p>

<p>Example: This example causes literal result elements that use the prefix <code>outxsl</code> to be used
to generate elements in the result tree that will be in the XSLT namespace. It assumes that both namespaces xsl and outxsl have been declared
and are in scope. Note that XSLT defines the namespace URI for the new elements, but it does not define
what namespace prefix will be used in the output (the keyword <code>result-prefix</code> is misleading).</p>
 
</font><div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
    &lt;xsl:namespace-alias stylesheet-prefix="outxsl" result-prefix="xsl"/&gt;
</pre>
    </font></td>
  </tr>
</table>
</div>


<hr>





<h3><a name="xsl:number">xsl:number</a></h3>


<p>The <b>xsl:number</b> element outputs the sequential number of a node in the source document.
 It takes an attribute <b>count</b> whose value is a pattern indicating which nodes to count;
 the default is to match all nodes of the same type and name as the current node.</p>

 <p>The <b>level</b> attribute may take three values: "single", "any", or "multiple".
  The default is "single".</p>

 <p>There is also an optional <b>from</b> attribute, which is also a pattern. 
  The exact meaning of this depends on the level.</p>


  <p>The calculation is as follows:</p>

 <table>
 <tr><td valign=top><font SIZE="2">level=single</td><td><font SIZE="2"><ol>
 <li>If the current node matches the pattern, the counted node is the current node. Otherwise the
 counted node is the innermost ancestor of the current node that matches the pattern. If no ancestor
 matches the pattern, the result is zero. If the from attribute is present, the counted node must be
 a descendant of a node that matches the "from" pattern.</li>
 <li>The result is one plus the number of elder siblings of the counted node that match the count pattern.</li>
 </ol></td></tr>

 <tr><td valign=top width="20%"><font SIZE="2">level=any</td><td><font SIZE="2">
 The result is the number of nodes in the document that match the count pattern, that are at or before
 the current node in document order, and that follow in document order the most recent node that matches the "from"
 pattern, if any. Typically this is used
 to number, say, the diagrams or equations in a document, or in some section or chapter of a document, regardless
 of where the diagrams or equations appear in the hierarchic structure.
 </td></tr>

 <tr><td valign=top width="20%"><font SIZE="2">level=multiple</td><td><font SIZE="2">
 The result of this is not a single number, but a list of numbers. There is one number in the list for each
 ancestor of the current element that matches the count pattern and that is a descendant of the anchor element.
 Each number is one plus the number of elder siblings of the relevant element that match the count pattern. The
 order of the numbers is "outwards-in".</td></tr></table>

<p>There is an optional <b>format</b> attribute which controls the output format. This contains an alternating
sequence of format-tokens and punctuation-tokens. A format-token is any sequence of alphanumeric characters,
a punctuation-token is any other sequence. The following
values (among others) are supported for the format-token:</p>

<table>
<tr><td width="60"><font SIZE="2">1</td><td><font SIZE="2">Sequence 1, 2, 3, ... 10, 11, 12, ...</td></tr>
<tr><td width="60"><font SIZE="2">001</td><td><font SIZE="2">Sequence 001, 002, 003, ... 010, 011, 012, ... (any number of
leading zeroes)</td></tr>
<tr><td><font SIZE="2">a</td><td><font SIZE="2">Sequence a, b, c, ... aa, ab, ac, ...</td></tr>
<tr><td><font SIZE="2">A</td><td><font SIZE="2">Sequence A, B, C, ... AA, AB, AC, ...</td></tr>
<tr><td><font SIZE="2">i</td><td><font SIZE="2">Sequence i, ii, iii, iv, ... x, xi, xii, ...</td></tr>
<tr><td><font SIZE="2">I</td><td><font SIZE="2">Sequence I, II, III, IV, ... X, XI, XII, ...</td></tr>
</table>

<p>There is also support for various Japanese sequences (Hiragana, Katakana, and Kanji) using
the format tokens &amp;#x3042, &amp;#x30a2, &amp;#x3044, &amp;#x30a4, &amp;#x4e00, and
for Greek and Hebrew sequences.</p>

<p>The format token "one" gives the sequence "one", "two", "three", ... , while "ONE" gives
the same in upper-case.</p>

<p>The default format is "1".</p>

<p>Actually, any sequence of ASCII digits in the format is treated in the same way: writing 999
 has the same effect as writing 001. A sequence of Unicode digits other than ASCII
digits (for exaple, Tibetan digits) can also be used, and will result in decimal numbering using those
digits.</p>

<p>Similarly, any other character classified as a letter can be used, and will result in "numbering" using
all consecutive Unicode letters following the one provided. For example, specifying "x" will give the
sequence x, y, z, xx, xy, xz, yx, yy, yz, etc. Specifying the Greek letter alpha (&amp;#178;) will
 cause "numbering" using the Greek letters up to "Greek letter omega with tonos" (&amp;#206;).
 Only "i" and "I" (for roman numbering), and the Japanese characters listed above, are exceptions to this rule.</p>

<p>Successive format-tokens in the format are used to process successive numbers in the list.
If there are more format-tokens in the format than numbers in the list,
the excess format-tokens and punctuation-tokens are ignored. If there are fewer format-tokens
in the format than numbers in the list, the last format-token and the punctuation-token that
 precedes it are used to format all excess numbers, with the final punctuation-token being used
  only at the end.</p>

  <p>Examples:<p>

  <table>
  <tr><td width=150><font SIZE="2"><b>Number(s)</td>
  <td width=150><font SIZE="2"><b>Format</td>
  <td width=150><font SIZE="2"><b>Result</td></tr>
  
  <tr><td><font SIZE="2">3</td>                <td><font SIZE="2">(1)</td>        <td><font SIZE="2">(3)</td></tr>
  <tr><td><font SIZE="2">12</td>               <td><font SIZE="2">I</td>          <td><font SIZE="2">XII</td></tr>
  <tr><td><font SIZE="2">2,3</td>              <td><font SIZE="2">1.1</td>        <td><font SIZE="2">2.3</td></tr>
  <tr><td><font SIZE="2">2,3</td>              <td><font SIZE="2">1(i)</td>       <td><font SIZE="2">2(iii)</td></tr>
  <tr><td><font SIZE="2">2,3</td>              <td><font SIZE="2">1.</td>         <td><font SIZE="2">2.3.</td></tr>
  <tr><td><font SIZE="2">2,3</td>              <td><font SIZE="2">A.1.1</td>      <td><font SIZE="2">B.3.</td></tr>
  <tr><td><font SIZE="2">2,3,4,5</td>          <td><font SIZE="2">1.1</td>        <td><font SIZE="2">2.3.4.5</td></tr>
  </table>
  
<p>This character may be preceded or followed by arbitrary punctuation (anything other than
these characters or XML special characters such as "&lt;") which is copied to the output verbatim.
For example, the value 3 with format "(a)" produces output "(c)".</p>

<p>It is also possible to use xsl:number to format a number obtained from an expression. This is achieved
using the value attribute of the xsl:number element. If this attribute is present, the count, level, and from
attributes are ignored.</p>

<p>With large numbers, the digits may be split into groups. For example, specify grouping-size="3" and
grouping-separator="/" to have the number 3000000 displayed as "3/000/000".</p>

<p>Negative numbers are always output in conventional decimal notation,
 regardless of the format specified.</p>

<p>Example: This example outputs the title child of an H2 element preceded by a composite number
 formed from the sequential number of the containing H1 element and the number of the containing H2 element.</p>
<div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
    &lt;xsl:template match="H2/TITLE"&gt;
        &lt;xsl:number count="H1"&gt;.&lt;xsl:number count="H2"&gt;
        &lt;xsl:text&gt &lt;/xsl:text&gt
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:template&gt;
</pre>
    </font></td>
  </tr>
</table>
</div>


<hr>





<h3><a name="xsl:otherwise">xsl:otherwise</a></h3>


<p>The <b>xsl:otherwise</b> element is used within an <b>xsl:choose</b> element to indicate the
default action to be taken if none of the other choices matches.</p>

<p>See <a href=#xsl:choose>xsl:choose</a>.</p>

<hr>

<h3><a name="xsl:output">xsl:output</a></h3>


<p>The <b>xsl:output</b> element is used to control the destination and format of the
principal output. It is always a top-level element immediately below the xsl:stylesheet element.
There may be multiple xsl:output elements; their values are accumulated as described in the
XSLT specification.</p>

<p>The following attributes may be specified:</p>

<table cellpadding="5">

<tr>
<td valign=top width="20%"><font SIZE="2">method</td>
<td><font SIZE="2">This indicates the format or destination of the output. The value "xml" indicates
XML output (though if disable-output-escaping is used there is no guarantee that it is well-formed).
A value of "html" is used for HTML output. The value "text" indicates plain text output: in this case
no markup may be written to the file using constructs such as literal result elements, xsl:element,
xsl:attribute, or xsl:comment. The value "xx:fop" (xx is any non-default namespace)
 indicates that output will be directed to the
<a href="http://xml.apache.org/fop">Formatting Object Processor</a> (FOP) produced by James Tauber: this
must be separately installed, it is not part of SAXON. Alternatively output can be directed
 to a user-defined
Java program by specifying the name of the class as the value of the method attribute, prefixed by
a namespace prefix, for example "xx:com.me.myjava.MyEmitter". The class must be
on the classpath, and must implement either the org.xml.sax.DocumentHandler interface, the
org.xml.sax.ContentHandler interface, or the
 com.icl.saxon.output.Emitter interface. The last of these, though proprietary, is a richer interface that
  gives access to additional information.</font></td>
</tr>


<tr>
<td valign=top><font SIZE="2">indent</td>
<td><font SIZE="2">as in the XSLT spec: values "yes" or "no" are accepted. The indentation
algorithm is different for HTML and XML. For HTML it avoids outputting extra space before or
after an inline element, but will indent text as well as tags, except in elements such as PRE
and SCRIPT. For XML, it avoids outputting extra whitespace except between two tags. The
emphasis is on conformance rather than aesthetics!</font></td>
</tr>

<tr>
<td valign=top><font SIZE="2">version</td>
<td><font SIZE="2">Determines the version of XML or HTML to be output. Currently this is
documentary only.</td>
</tr>

<tr>
<td valign=top><font SIZE="2">encoding</td>
<td><font SIZE="2">A character encoding, e.g. iso-8859-1 or utf-8. The value must be one recognised
both by the Java run-time system and by Saxon itself: the encoding names that Saxon recognises are ASCII,
US-ASCII, iso-8859-1, utf-8, utf8, KOI8R, cp1251. It is used for three distinct purposes: to control character conversion
by the Java I/O routines; to determine which characters will be represented as character entities; and
to document the encoding in the output file itself. The default (and fallback) is utf-8.</td>
</tr>

<tr>
<td valign=top><font SIZE="2">media-type</td>
<td><font SIZE="2">For example, "text/xml" or "text/html". This is largely documentary. However,
the value assigned is passed back to the calling application in the OutputDetails object, where
is can be accessed using the getMediaType() method. The supplied servlet application SaxonServlet
uses this to set the media type in the HTTP header.</td>
</tr>

<tr>
<td valign=top><font SIZE="2">doctype-system</td>
<td><font SIZE="2">This is used only for XML output: it is copied into the DOCTYPE declaration
as the system identifier</td>
</tr>

<tr>
<td valign=top><font SIZE="2">doctype-public</td>
<td><font SIZE="2">This is used only for XML output: it is copied into the DOCTYPE declaration
as the public identifier. It is ignored if there is no system identifier.</td>
</tr>

<tr>
<td valign=top><font SIZE="2">omit-xml-declaration</td>
<td><font SIZE="2">The values are "yes" or "no".
For XML output this controls whether an xml declaration should be output; the default is "no".
</td>
</tr>

<tr>
<td valign=top><font SIZE="2">standalone</td>
<td><font SIZE="2">This is used only for XML output: if it is present, a standalone attribute
is included in the XML declaration, with the value "yes" or "no".</td>
</tr>

<tr>
<td valign=top><font SIZE="2">cdata-section-elements</td>
<td valign=top><font SIZE="2">This is used only for XML output. It is a whitespace-separated list of
 element names. Character data belonging to these output elements will be written within CDATA
 sections.</td></tr>


</table>

</font>


<hr>



<h3><a name="xsl:param">xsl:param</a></h3>


<p>The <b>xsl:param</b> element is used to define a formal parameter to a template,
or to the stylesheet.</p>

<p>As a template parameter, it must be used as an immediate child of the xsl:template element.
As a stylesheet parameter, it must be used as an immediate child of the xsl:stylesheet element.</p>

<p>There is a mandatory attribute, <b>name</b>, to define the name
of the parameter. The default value of the parameter may be defined either by a select attribute, or by the
contents of the xsl:param element, in the same way as for xsl:variable. The default value is ignored
if an actual parameter is supplied with the same name.</p>


<hr>




<h3><a name="xsl:preserve-space">xsl:preserve-space</a></h3>


<p>The <xsl:preserve-space> element is used at the top level of the stylesheet to define elements in the source
document for which white-space nodes are significant and should be retained.</p>

<p>The <b>elements</b> attribute is mandatory, and defines a space-separated list of element names.
The value "*" may be used to mean "all elements"; in this case any elements where whitespace is not
to be preserved may be indicated by an <a href="#xsl:strip-space">xsl:strip-space</a> element.</p>


</font>
<hr>




<h3><a name="xsl:processing-instruction">xsl:processing-instruction</a></h3>


<p>The <b>xsl:processing-instruction</b> element can appear anywhere within an xsl:template.
 It causes an XML processing
instruction to be output.</p>

<p>There is a mandatory <b>name</b> attribute which gives the name of the PI. This attribute is interpreted
as an <i>attribute value template</i>, so it may contain string expressions within curly braces.</p>

<p>The content of the xsl:processing-instruction element is expanded to form the data part of the PI.<p>

<p>For example:</p>
<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:processing-instruction name="submit-invoice"&gt;version="1.0"&lt;/xsl:processing-instruction&gt;
</pre></font></td>
  </tr>
</table>
</div><font SIZE="2">

<p>Note that special characters occurring within the PI text will <i>not</i>
be escaped.</p>


</font>

<hr>



<h3><a name="xsl:sort">xsl:sort</a></h3>


<p>The <b>xsl:sort</b> element is used within an <b>xsl:for-each</b> or <b>xsl:apply-templates</b>
or <b>saxon:group</b> element to indicate the order in which the selected elements are processed.</p>

<p>The <b>select</b> attribute (default value ".") is a string expression that calculates the sort
key.</p>

<p>The <b>order</b> attribute (values "ascending" or "descending", default "ascending") determines
the sort order. There is no control over language, collating sequence, or data type.</p>

<p>The <b>data-type</b> attribute (values "text" or "number") determines whether collating is based
on alphabetic sequence or numeric sequence.</p>

<p>The <b>case-order</b> attribute (values "upper-first" and "lower-first") is relevant only for
data-type="text"; it determines whether uppercase letters are sorted before their lowercase equivalents,
or vice-versa.</p>

<p>The value of the <b>lang</b> attribute can be an ISO language code such as "en" (English) or
 "de" (German). It determines the algorithm used for alphabetic collating. The default is based on
 the Java system locale. The only collating sequence supplied with the SAXON product is "en" (English),
 but other values may be supported by writing a user-defined comparison class. If no comparison class
 is found for the specified language, a default algorithm is used which simply sorts according
 to Unicode binary character codes. The value of lang does not have to be a recognized language
 code, it is also possible to use values such as "month" to select a data-type-specific collating
 algorithm.</p>

<p>Several sort keys are allowed: they are written in major-to-minor order.</p>

<p>Example 1: sorting with xsl:apply-templates. This example shows a template for a BOOKLIST
element which processes all the child BOOK elements in order of their child AUTHOR elements; books
with the same author are in descending order of the DATE attribute.</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;BOOKLIST&quot;&gt;
    &lt;h2&gt;
        &lt;xsl:apply-templates select="BOOK"&gt;
            &lt;xsl:sort select="AUTHOR"/&gt;
            &lt;xsl:sort select="@DATE" order="descending" lang="GregorianDate"/&gt;
        &lt;/xsl:apply-templates&gt;            
    &lt;/h2&gt;
&lt;/xsl:template&gt;</pre>
    </font></td>
  </tr>
</table>
</div><font SIZE="2">
</font>


<p>Example 2: sorting with xsl:for-each. This example also shows a template for a BOOKLIST
element which processes all the child BOOK elements in order of their child AUTHOR elements.</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;BOOKLIST&quot;&gt;
    &lt;h2&gt;
        &lt;xsl:for-each select="BOOK"&gt;
            &lt;xsl:sort select="AUTHOR"/&gt;
            &lt;p&gt;AUTHOR: &lt;xsl:value-of select="AUTHOR"&gt;&lt;/p&gt;
            &lt;p&gt;TITLE: &lt;xsl:value-of select="TITLE"&gt;&lt;/p&gt;
            &lt;hr/&gt;
        &lt;/xsl:for-each&gt;            
    &lt;/h2&gt;
&lt;/xsl:template&gt;</pre>
    </font></td>
  </tr>
</table>
</div><font SIZE="2">
</font>


<hr>


<h3><a name="xsl:script">xsl:script</a></h3>


<p>The <xsl:script> element is used at the top level of the stylesheet to define the implementation
of extension functions. The element was defined in the draft XSLT 1.1 specification of
8 December 2000. It is available only when the <code>xsl:stylesheet</code> element
specifies a value other than <code>version="1.0"</code>.</p>

<p><i>Note: XSLT 2.0 subsequently deleted this element, and with it, all attempts to standardize
bindings to extension functions.</i></p>

<p>The <b>language</b> attribute is mandatory, and must take the value "java". 
The values "javascript", "ecmascript", or a QName are also permitted, but in this
case Saxon ignores the xsl:script element.</p>

<p>The <b>implements-prefix</b> attribute is mandatory, its value must be a namespace
prefix that maps to the same namespace URI as the prefix used in the extension function
call.</p>

<p>The <b>src</b> attribute is mandatory for language="java", its value must take the
form "java:fully.qualified.class.Name", for example "java:java.util.Date". It defines
the class containing the implementation of extension functions that use this prefix.</p>

<p>The <b>archive</b> attribute is optional, its value is a space-separated list of URLs
of folders or JAR files that will be searched to find the named class. If the attribute
is omitted, the class is sought on the classpath.</p>

<p>The element name <b>saxon:script</b> may be used as a synonym for xsl:script ("saxon" being
the conventional prefix for the namespace "http://icl.com/saxon"). Using the synonym enables
you to define an implementation which Saxon will use, but other processors will ignore.</p>

<hr>


<h3><a name="xsl:strip-space">xsl:strip-space</a></h3>


<p>The <xsl:strip-space> element is used at the top level of the stylesheet to define elements in the source
document for which white-space nodes are insignificant and should be removed from the tree before processing.</p>

<p>The <b>elements</b> attribute is mandatory, and defines a space-separated list of element names.
The value "*" may be used to mean "all elements"; in this case any elements where whitespace is not
to be stripped may be indicated by an <a href="#xsl:preserve-space">xsl:preserve-space</a> element.</p>


<hr>





<h3><a name="xsl:stylesheet">xsl:stylesheet</a></h3>


<p>The <b>xsl:stylesheet</b> element is always the top-level element of an XSL stylesheet. The
name <b>xsl:transform</b> may be used as a synonym.</p>

<p>The following attributes may be specified:</p>

<table cellpadding="5">

<tr>
<td valign=top><font SIZE="2">version</td>
<td><font SIZE="2">Mandatory. A value other than "1.0" invokes forwards compatibility mode.</td>
</tr>


<tr>
<td valign=top><font SIZE="2">saxon:trace</td>
<td><font SIZE="2">Value "yes" or "no": default no. If set to "yes", causes activation
of templates to be traced on System.err for diagnostic purposes. The value may be overridden
by specifying a saxon:trace attribute on the individual template.</td>
</tr>


</table>

</font>

<hr>



<h3><a name="xsl:template">xsl:template</a></h3>


<p>The <b>xsl:template</b> element defines a processing rule for source elements or other nodes of a
particular type.</p>

<p>The type of node to be processed is identified by a pattern, written in the
mandatory <b>match</b> attribute. The most common form of pattern is simply an
element name. However, more complex patterns may also be used:
The full syntax of patterns is given in <a href="patterns.html">XSLT Pattern Syntax</a></h3>

<p>The following examples show some of the possibilities:</p>
</font>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="590">
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2"><b>Pattern</b></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2"><b>Meaning</b></font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">XXX</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any element whose name (tag) is XXX</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2"><b>*</b></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any element</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">XXX/YYY</i></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any YYY element 
    whose parent is an XXX</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">XXX//YYY</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any YYY element that has an ancestor named XXX</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">/*/XXX</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any XXX element that is immediately below
    the root (document) element</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">*[@ID]</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any element with an ID attribute</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">XXX[1]</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any XXX element that is the first XXX child of
    its parent element. (Note that this kind of pattern can be very inefficient: it is better to match all XXX
    elements with a single template, and then use xsl:if to distinguish them)</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">SECTION[TITLE="Contents"]</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any SECTION element whose first TITLE child element
    has the value "Contents"</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">A/TITLE | B/TITLE | C/TITLE</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any TITLE element whose parent is of type A or B or C</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">text()</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any character data node</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">@*</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches any attribute</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">/</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">Matches the document node</font></td>
  </tr>
</table>


<p>The xsl:template element has an optional <b>mode</b> attribute. If this is present, the template
will only be matched when the same mode is used in the invoking <b>xsl:apply-templates</b> element.</p>

<p>There is also an optional <b>name</b> attribute. If this is present, the template may be invoked
directly using xsl:call-template. The match attribute then becomes optional.</p>

<p>If there are several <strong>xsl:template</strong> elements that all match the same
node, the one that is chosen is determined by the optional <b>priority</b> attribute: the template
with highest priority wins. The priority is written as a floating-point number; the default priority
is 1. If two matching templates have the same priority, the one that appears last in the stylesheet
is used.</p>

 <p>The attribute saxon:trace="yes" or "no" may be applied
 either at the xsl:template level or at the xsl:stylesheet level (it is treated as an inherited attribute).
 If the value for a template is "yes", every activation of that template results
 in a line of output to System.err, identifying the stylesheet template and the current node in the
 source document, by element type and line number. Tracing only occurs if the template is
 activated by matching the pattern, not if the template is called by name.</p>

<b>

<p>Examples:</p>
</b>

<p>The following examples illustrate different kinds of template and match pattern.</p>

<p><em>Example 1</em>: a simple XSL template for a particular element. This example causes
all &lt;ptitle&gt; elements in the source document to be output as HTML &lt;h2&gt;
elements.</p>
<div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;ptitle&quot;&gt;
    &lt;h2&gt;
        &lt;xsl:apply-templates/&gt;
    &lt;/h2&gt;
&lt;/xsl:template&gt;</pre>
    </font></td>
  </tr>
</table>
</div>


<hr>


<h3><a name="xsl:text">xsl:text</a></h3>


<p>The <b>xsl:text</b> element causes its content to be output.</p>

<p>The main reasons for enclosing text within an xsl:text element is
to allow white space to be output.
White space nodes in the stylesheet are ignored unless they appear immediately within
an xsl:text element.</p>

<p>The optional <b>disable-output-escaping</b> attribute may be set to "yes" or "no"; the default is
"no". If set to "yes", special characters such as "&lt;" and "&amp;" will be output as themselves,
not as entities. Be aware that in general this can produce non-well-formed XML or HTML. It is useful,
however, when generating things such as ASP or JSP pages. Escaping may not be disabled when writing
to a result tree fragment.</p>

<hr>






<h3><a name="xsl:value-of">xsl:value-of</a></h3>


<p>The <b>xsl:value-of</b> element evaluates an expression as a string,
 and outputs its value to the current output stream.
<p>The full syntax of expressions is given in <a href="expressions.html">XPath Expression Syntax</a>.
</p>

<p>The <b>select</b> attribute identifes the expression, and is mandatory.</p>

<p>The optional <b>disable-output-escaping</b> attribute may be set to "yes" or "no"; the default is
"no". If set to "yes", special characters such as "&lt;" and "&amp;" will be output as themselves,
not as entities. Be aware that in general this can produce non-well-formed XML or HTML. It is useful,
however, when generating things such as ASP or JSP pages. Escaping may not be disabled when writing
to a result tree fragment.</p>

<p>If the select expression is a node-set expression that selects more than one node, only the
first is considered. If it selects no node, the result is an empty string.</p>

<p>Here are some examples of expressions that can be used in the select attribute:</p>



<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="590">
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2"><b>Expression</b></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2"><b>value</b></font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">TITLE</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The character content of the first child TITLE element if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">@NAME</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The value of the NAME attribute of the current element if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">.</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The expanded character content of the current element</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">../TITLE</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The expanded character content of the first TITLE child of the
    parent element, if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">ancestor::SECTION/TITLE</i></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The expanded character content of the first TITLE child of the
    enclosing SECTION element, if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">ancestor::*/TITLE</i></font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The expanded character content of the first TITLE child of the
    nearest enclosing element that has a child element named TITLE</font></td>
  </tr>

  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">PERSON[@ID]</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The content of the first child PERSON element having an ID attribute,
    if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">*[last()]/@ID</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The value of the ID attribute of the last child element of any type,
     if there are any </font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">.//TITLE</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The content of the first descendant TITLE element if there is one</font></td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">sum(*/@SALES)</font></td>
    <td WIDTH="50%" VALIGN="TOP"><font SIZE="2">The numeric total of the values of the SALES attributes of all child
    elements that have a SALES attribute</font></td>
  </tr>


</table>




<hr>





<h3><a name="xsl:variable">xsl:variable</a></h3>


<p>The <b>xsl:variable</b> element is used to declare a variable and give it a value. If it appears at the
top level (immediately within xsl:stylesheet) it declares a global variable, otherwise it declares a local variable
that is visible only within the stylesheet element containing the xsl:variable declaration.</p>

<p>The mandatory <b>name</b> attribute defines the name of the variable.</p> 

<p>The value of the variable may be defined either by an expression within the optional <b>select</b> attribute, or
by the contents of the xsl:variable element. In the latter case the result is technically a value of type
<i>Result Tree Fragment</i>, although it may be used for most practical purposes as if it were a String. (The difference
is that a Result Tree Fragment may contain element start and end tags).</p>

<p>In standard XSL, variables once declared cannot be updated. SAXON however provides a <a href="extensions.html#saxon:assign">
saxon:assign</a> extension element to circumvent this restriction. SAXON also provides an extension function
to convert a result tree fragment to a node-set, allowing further processing of its contents to take place.</p>

<p>The value of a variable can be referenced within an expression using the syntax <b>$name</b>.</p>

<p>Example:</p>
</font><div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font face="Courier New" size="3">
    <pre>
&lt;xsl:variable name=&quot;title&quot;&gt;A really exciting document&quot;&lt;/xsl:variable&gt;
&lt;xsl:variable name=&quot;backcolor&quot; expr=&quot;'#FFFFCC'&quot; /&gt;
&lt;xsl:template match="/*"&gt;
    &lt;HTML&gt;&lt;TITLE&lt;xsl:value-of select=&quot;$title&quot;/&gt;&lt;/TITLE&gt;
    &lt;BODY BGCOLOR='{$backcolor}'&gt;
    ...<br>
    &lt;/BODY&gt;&lt;/HTML&gt;
&lt;/xsl:template&gt;
</pre>
    </font></td>
  </tr>
</table>
</div><font SIZE="2">


</font>

<hr>



<h3><a name="xsl:when">xsl:when</a></h3>


<p>The <b>xsl:when</b> element is used within an <b>xsl:choose</b> element to indicate one
of a number of choices. It takes a mandatory parameter, <b>test</b>, whose value is a match
pattern. If this is the first xsl:when element within the enclosing xsl:choose whose test
 condition matches the current element, the content of the xsl:when element is expanded, otherwise
 it is ignored.</p>
 
</font>

<hr>


<h3><a name="xsl:with-param">xsl:with-param</a></h3>


<p>The <b>xsl:with-param</b> element is used to define an actual parameter to a template. It may be used
within an xsl:call-template or an xsl:apply-templates or an xsl:apply-imports element.
For an example, see the <a href="#xsl:template"><b>xsl:template</b></a> section.</p>

<p>There is a mandatory attribute, <b>name</b>, to define the name
of the parameter. The value of the parameter may be defined either by a select attribute, or by the
contents of the xsl:param element, in the same way as for xsl:variable.</p>

<p><i>The parameter has no effect unless the called template includes a matching
<b>xsl:param</b> element. </i></p>


<hr>





<h2><a name="Literal result elements">Literal result elements</a></h2>


<p>Any elements in the style sheet other than those listed above are
assumed to be literal result elements, and are copied to the current output stream at the
position in which they occur.</p>

<p>Attribute values within literal result elements are treated as attribute value templates:
they may contain string expressions enclosed between curly braces. For the syntax of 
string expressions, see <strong><a href="#xsl:value-of">xsl:value-of</a></strong> above.</p>

<p>Where the output is HTML, certain formatting elements are recognised as empty
 elements: these are AREA, BASEFONT, BR, COL, FRAME, HR, IMG, INPUT, ISINDEX,
 LINK, META, and SYSTEM (in either upper or lower case, and optionally with attributes, of course).
 These should be written as empty
XML elements in the stylesheet, and will be written to the HTML output stream without a
closing tag.</p>

<p>With HTML output, if the attribute name is the same as its value, the abbreviated form
of output is used: for example if &lt;OPTION SELECTED="SELECTED"&gt; appears in the stylesheet,
it will be output as &lt;OPTION SELECTED&gt.</p>

<p>A simple stylesheet may be created by using a literal result element as the top-level
element of the stylesheet. This implicitly defines a single template with a match pattern
of "/". In fact, an XHTML document constitutes a valid stylesheet which will be output as a copy
of itself, regardless of the contents of the source XML document.</p>

<hr>
<p align="center"><a HREF="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</a> <br>
10 August 2003</p>
</body>
</html>
