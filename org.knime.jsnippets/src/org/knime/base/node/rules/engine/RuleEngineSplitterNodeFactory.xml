<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE knimeNode PUBLIC "-//UNIKN//DTD KNIME Node 2.0//EN" "http://www.knime.org/Node.dtd">
<knimeNode type="Manipulator" icon="./rule_engine_splitter.png">
	<name>Rule-based Splitter</name>
	<shortDescription>
		 Splits the input table based on user-defined business rules
	</shortDescription>
	
	<fullDescription>
		<intro>This node takes a list of user-defined rules and tries to match them to each
        row in the input table. Depending on a rule match and settings, the row will be sent to the first or second output table.
        The rules follow a limited SQL-like syntax:
        <pre>
LINE := RULE | '//' [^\n]*
RULE := BEXPR ('=&gt;' SINGLE)?
SINGLE := CONST | REF
BEXPR := PREBEXPR |
         AEXPR (op=BOP PREBEXPR (op PREBEXPR)*)?
PREBEXPR := '(' BEXPR ')' |
            'NOT' BEXPR |
            'MISSING' COL
AEXPR := SINGLE OP SINGLE |
         SINGLE LOP LIST
BOP := 'AND' | 'OR' | 'XOR'
OP := '&gt;' | '&lt;' | '&gt;=' | '&lt;=' |
      '=' | 'LIKE' | 'CONTAINS' | 'MATCHES'
LOP := 'IN'
STRING := '&quot;' [^&quot;]* '&quot;'
NUMBER := '-'? POSITIVE
POSITIVE := ([0-9]*\.[0-9]*('E''-'?[1-9][0-9]*)?) |
            [0-9]+('E''-'?[1-9][0-9]*)? | 'Infinity'
COL := '$' [^$]+ '$'
REF := COL | FLOWVAR | TABLEREF
FLOWVAR := '$${' ('D' | 'I' | 'S') [^}]+ '}$$'
TABLEREF := '$$ROWID$$' | '$$ROWINDEX$$' | '$$ROWCOUNT$$'
CONST := STRING | NUMBER
LIST := '(' SINGLE (',' SINGLE)* ')'
        </pre>
        <p>
        The comments start with <tt>//</tt>, and anything after that is not interpreted as a rule in that line.
	 	Rules consist of a condition part (antecedent), that must evaluate to <i>true</i>
        or <i>false</i>, and possibly an outcome (consequent) which is ignored.
        The most simple rule is a comparison between a column and another column, a fixed number or string.
        The MISSING operator matches if and only if the value in the argument column is missing.
        The LIKE operator treats the fixed string as a wildcard pattern (with * and ?) as wildcards,
        the CONTAINS operator checks whether the regular expression appears in the left expression,
        the MATCHES operator uses the right regular expressions to check whether the left expression, 
        the IN operator compares the column value to a list of strings and evaluates to <i>true</i> if at least
        one value in the list is equal to the column's value. Note that all operators are case-sensitive!
        Please also note that the NOT negates all following expressions, not just the direct following.
        </p>
        <p>The outcome of a rule can either be a fixed string, a fixed number, or a reference to another column or flow variable value.
        </p>
        <p>
        Columns are given by their name surrounded by $, numbers are given in the usual decimal representation. Note that
        strings must not contain (double-)quotes. The flow variables are represented by <b>$${</b>TypeCharacterAndFlowVarName<b>}$$</b>.
        The TypeCharacter should be 'D' for double (real) values, 'I' for integer values and 'S' for strings.
        </p>
        <p>Rules can (and should) be grouped with brackets because there is not pre-defined
        operator precedence for the logical connectives (NOT, AND, OR, XOR) (comparison operators always take precedence
        over logical connectives).</p>
        <p>The <tt>ROWID</tt> represents the row key string, the <tt>ROWINDEX</tt> is a the index of the row (first row has <tt>1</tt> value),
        while <tt>ROWCOUNT</tt> stands for the number of rows in the table.</p>
        <p>Some example rules (each should be in one line):</p>
        <pre>
// This is a comment
$Col0$ > 5
$Col0$ = "Active" AND $Col1$ &lt;= 5
$Col0$ LIKE "Market Street*" AND 
    ($Col1$ IN ("married", "divorced") 
        OR $Col2$ > 40) => "Strange"
$Col0$ CONTAINS $${SFlowVar0}$$ OR $$ROWINDEX$$ &lt; $${IFlowVar1}$$
$Col0$ > 5
"Hello world" CONTAINS "l+o" => "Always true"
        </pre>
        <p>
        You can use either Ctrl+Space to insert predefined parts, or select them from the upper controls.
        </p>
		</intro>
		
		<option name="Column List">Available columns, which can be used as variables in a rule.</option>
		<option name="Flow Variable List">Available flow variables, which can be used as variables in a rule.</option>
		<option name="Category">The operator categories.</option>
		<option name="Function">A list of valid operators in the selected category.</option>
		<option name="Description">Short help about the operator.</option>
		<option name="Expression">The rule editor. You have completion, each row represents a rule.</option>
		<option name="any rule matches -> first, others second">The row will be included in the first output if any of the rules matches, the rest go to second.</option>
		<option name="any rule matches -> second, others -> first">The row will be included in the second output if any of the rules matches, the rest go to first.</option>
	</fullDescription>
	
	<ports>
		<inPort index="0" name="To be filtered">Datatable from which to filter rows.</inPort>
		<outPort index="0" name="Filtered">Datatable with rows matching any of the conditions, or matching none if that selected.</outPort>
        <outPort index="1" name="Filtered Out">Datatable with rows not meeting the specified criteria</outPort>
	</ports>
</knimeNode>