package org.knime.core.node.workflow;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.knime.core.node.ExecutionMonitor;
import org.knime.core.node.workflow.WorkflowPersistor.LoadResultEntry.LoadResultEntryType;
import org.knime.core.node.workflow.WorkflowPersistor.WorkflowLoadResult;
import org.knime.core.util.FileUtil;

/**
 * @author Magnus Gohm, KNIME AG, Konstanz, Germany
 */
public class BugAP23946_CaptureWorkflowEnd_CapturesSideBranch extends WorkflowTestCase {

    private File m_testCaseDir;
    private NodeID m_captureWorkflowStart_6;
    private NodeID m_captureWorkflowEnd_11;
    private NodeID m_RowFilter_4;

    @BeforeEach
    public void setUp() throws Exception {
        m_testCaseDir = FileUtil.createTempDir(getClass().getSimpleName());
        FileUtils.copyDirectoryToDirectory(getDefaultWorkflowDirectory(), m_testCaseDir);
    }
    
    private WorkflowLoadResult initWorkflowFromTemp() throws Exception {
        File workflow =  new File(m_testCaseDir, "bugAP23946_CaptureWorkflowEnd_CapturesSideBranch");
        WorkflowLoadResult loadResult = loadWorkflow(workflow, new ExecutionMonitor());
        setManager(loadResult.getWorkflowManager());
        NodeID baseID = getManager().getID();
        m_captureWorkflowStart_6 = new NodeID(baseID, 6);
        m_captureWorkflowEnd_11 = new NodeID(baseID, 11);
        m_RowFilter_4 = new NodeID(baseID, 4);
        return loadResult;
    }

    /**
     * Sets the output folder for the workflow writer node, removes the connection to the side 
     * branch which contains the additional capture workflow group, executes the workflow writer
     * and asserts that the generated workflow only contains the nodes from the main branch and does 
     * not have any node from the side branch.
     * 
     * @throws Exception
     */
    @Test
    public void testWriteWorkflowAfterRemovingSideBranchWithAdditionalCaptureWorkflowGroup() throws Exception {
        var loadResult = initWorkflowFromTemp();
        WorkflowManager manager = loadResult.getWorkflowManager();
         
        // Set workflow dir folder path to string configuration node
        Map<String, String> configuration = new HashMap<>();
        configuration.put("output_location", m_testCaseDir.getAbsolutePath());
        manager.setConfigurationNodesFromString(configuration);

        // Remove connection to side branch
        ConnectionContainer connection = findInConnection(m_captureWorkflowStart_6, 1);
        assertNotNull(connection);
        assertTrue(manager.canAddConnection(m_captureWorkflowEnd_11, 1, m_captureWorkflowStart_6, 1));
        assertTrue(manager.canRemoveConnection(connection));
        manager.removeConnection(connection);
        manager.addConnection(m_captureWorkflowEnd_11, 1, m_captureWorkflowStart_6, 1);

        manager.resetAndConfigureAll();
        executeAllAndWait();

        // Retrieve workflow manager of the workflow generated by the workflow writer with (NodeID = 3)
        File generatedWorkflow = new File(m_testCaseDir, "SavedWorkflow");
        WorkflowLoadResult generatedLoadResult = loadWorkflow(generatedWorkflow, new ExecutionMonitor());
        WorkflowManager generatedManager = generatedLoadResult.getWorkflowManager();

        assertThat("Unexpected result when loading generated workflow", generatedLoadResult.getType(),
                is(LoadResultEntryType.Ok));
        assertThat("Unexpected number of nodes in generated workflow", generatedManager.getWorkflow().getNrNodes(),
                is(3));
        NodeID generatedRowFilter_4 = generatedManager.getID().createChild(m_RowFilter_4.getIndex());
        NodeID generatedWorkflowServiceInput_5 = generatedManager.getID().createChild(5);
        NodeID generatedWorkflowServiceOutput_6 = generatedManager.getID().createChild(6);
        Set<ConnectionContainer> incomingConnectionsForRowFilter = generatedManager
                .getIncomingConnectionsFor(generatedRowFilter_4);
        assertTrue(!incomingConnectionsForRowFilter.isEmpty(), 
        		"Expected Row Filter to have input connection in generated workflow");
        assertThat("Unexpected Row Filter predecessor",
                incomingConnectionsForRowFilter.stream().findFirst().get().getSource(),
                is(generatedWorkflowServiceInput_5));
        Set<ConnectionContainer> outgoingConnectionsForRowFilter = generatedManager
                .getOutgoingConnectionsFor(generatedRowFilter_4);
        assertTrue(!outgoingConnectionsForRowFilter.isEmpty(), 
        		"Expected Row Filter to have input connection in generated workflow");
        assertThat("Unexpected Row Filter successor",
                outgoingConnectionsForRowFilter.stream().findFirst().get().getDest(),
                is(generatedWorkflowServiceOutput_6));

        generatedManager.getParent().removeProject(generatedManager.getID());
    }

    @Override
    @AfterEach
    public void tearDown() throws Exception {
        super.tearDown();
        FileUtil.deleteRecursively(m_testCaseDir);
    }
    
}
